#version 450
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Match configuration
// Optimized with uvec4 vector types for SIMD operations
layout(set = 0, binding = 0) uniform MatchConfig {
    uint num_names;           // Number of filenames to match
    uint pattern_len;         // Length of the pattern
    uint flags;               // Match flags
    uint max_name_len;        // Maximum filename length
    uint names_offset;        // Offset to names data
    uint names_lengths_offset; // Offset to name lengths
    uint _pad1;
    uint _pad2;
} config;

// Match flags
const uint FLAG_CASE_INSENSITIVE = 1u;
const uint FLAG_MATCH_PATH = 2u;      // Match full path instead of basename
const uint FLAG_PERIOD = 4u;          // Leading period must be matched explicitly

// Result for each filename
struct MatchResult {
    uint name_idx;
    uint matched;
    uint _pad1;
    uint _pad2;
};

// Buffers
layout(set = 0, binding = 1) readonly buffer Pattern {
    uint pattern_data[];
};

layout(set = 0, binding = 2) readonly buffer NamesData {
    uint names_data[];
};

layout(set = 0, binding = 3) readonly buffer NameOffsets {
    uint name_offsets[];
};

layout(set = 0, binding = 4) readonly buffer NameLengths {
    uint name_lengths[];
};

layout(set = 0, binding = 5) writeonly buffer Results {
    MatchResult results[];
};

layout(set = 0, binding = 6) buffer MatchCount {
    uint match_count;
};

#include "string_ops.glsl"

// Common functions from string_ops.glsl:
// to_lower, to_lower_word, char_match

// Buffer access functions (specific to this shader's buffer layout)

// Get byte from pattern buffer
uint read_pattern_char(uint byte_index) {
    uint word_index = byte_index >> 2u;  // / 4
    uint byte_offset = byte_index & 3u;  // % 4
    uint word = pattern_data[word_index];
    return (word >> (byte_offset << 3u)) & 0xFFu;  // * 8
}

// Get byte from names buffer
uint read_name_char(uint byte_index) {
    uint word_index = byte_index >> 2u;
    uint byte_offset = byte_index & 3u;
    uint word = names_data[word_index];
    return (word >> (byte_offset << 3u)) & 0xFFu;
}

// Get 4 bytes as a packed word from names buffer at arbitrary byte position
uint get_name_word_at(uint byte_pos) {
    uint word_idx = byte_pos >> 2u;
    uint byte_offset = byte_pos & 3u;

    if (byte_offset == 0u) {
        return names_data[word_idx];
    }

    // Unaligned access - combine two words
    uint w0 = names_data[word_idx];
    uint w1 = names_data[word_idx + 1u];
    uint shift = byte_offset << 3u;
    return (w0 >> shift) | (w1 << (32u - shift));
}

// Simple glob pattern matching (supports * and ?)
bool glob_match(
    uint pattern_start,
    uint pattern_len,
    uint name_start,
    uint name_len,
    bool case_insensitive,
    bool match_period
) {
    uint pi = 0;  // pattern index
    uint ni = 0;  // name index
    uint star_pi = 0xFFFFFFFF;  // position of last * in pattern
    uint star_ni = 0xFFFFFFFF;  // position in name when * was seen

    // Handle leading period rule
    if (match_period && name_len > 0) {
        uint first_char = read_name_char(name_start);
        if (first_char == 46) { // '.'
            if (pattern_len == 0) return false;
            uint first_pat = read_pattern_char(pattern_start);
            if (first_pat != 46) return false;
        }
    }

    while (ni < name_len) {
        if (pi < pattern_len) {
            uint pc = read_pattern_char(pattern_start + pi);
            uint nc = read_name_char(name_start + ni);

            if (pc == 42) { // '*'
                star_pi = pi;
                star_ni = ni;
                pi++;
                continue;
            } else if (pc == 63) { // '?'
                if (match_period && ni == 0 && nc == 46) { // '.'
                    if (star_pi != 0xFFFFFFFF) {
                        pi = star_pi + 1;
                        ni = ++star_ni;
                        continue;
                    }
                    return false;
                }
                pi++;
                ni++;
                continue;
            } else if (pc == 91) { // '['
                // Character class - simplified implementation
                bool negated = false;
                bool matched = false;
                uint ci = pi + 1;

                if (ci < pattern_len) {
                    uint next_c = read_pattern_char(pattern_start + ci);
                    if (next_c == 33 || next_c == 94) { // '!' or '^'
                        negated = true;
                        ci++;
                    }
                }

                // Find matching character in class
                while (ci < pattern_len) {
                    uint cc = read_pattern_char(pattern_start + ci);
                    if (cc == 93) break; // ']'

                    // Handle range (e.g., a-z)
                    if (ci + 2 < pattern_len) {
                        uint dash = read_pattern_char(pattern_start + ci + 1);
                        uint range_end_c = read_pattern_char(pattern_start + ci + 2);
                        if (dash == 45 && range_end_c != 93) { // '-' and not ']'
                            uint test_c = case_insensitive ? to_lower(nc) : nc;
                            uint rs = case_insensitive ? to_lower(cc) : cc;
                            uint re = case_insensitive ? to_lower(range_end_c) : range_end_c;
                            if (test_c >= rs && test_c <= re) {
                                matched = true;
                            }
                            ci += 3;
                            continue;
                        }
                    }

                    if (char_match(cc, nc, case_insensitive)) {
                        matched = true;
                    }
                    ci++;
                }

                // Skip to end of character class
                while (pi < pattern_len && read_pattern_char(pattern_start + pi) != 93) pi++;
                if (pi < pattern_len) pi++; // skip ']'

                if (negated) matched = !matched;

                if (!matched) {
                    if (star_pi != 0xFFFFFFFF) {
                        pi = star_pi + 1;
                        ni = ++star_ni;
                        continue;
                    }
                    return false;
                }
                ni++;
                continue;
            } else {
                // Regular character match
                if (char_match(pc, nc, case_insensitive)) {
                    pi++;
                    ni++;
                    continue;
                }
            }
        }

        // No match - try backtracking to last *
        if (star_pi != 0xFFFFFFFF) {
            pi = star_pi + 1;
            ni = ++star_ni;
            continue;
        }

        return false;
    }

    // Skip trailing stars in pattern
    while (pi < pattern_len && read_pattern_char(pattern_start + pi) == 42) {
        pi++;
    }

    return pi == pattern_len;
}

// Find start of basename in path using vectorized '/' search
uint find_basename_start(uint path_start, uint path_len) {
    uint start = 0u;
    uint i = 0u;

    // Process 4 bytes at a time
    while (i + 4u <= path_len) {
        uint word = get_name_word_at(path_start + i);
        // Check each byte for '/' (0x2F = 47)
        if ((word & 0xFFu) == 47u) start = i + 1u;
        if (((word >> 8u) & 0xFFu) == 47u) start = i + 2u;
        if (((word >> 16u) & 0xFFu) == 47u) start = i + 3u;
        if (((word >> 24u) & 0xFFu) == 47u) start = i + 4u;
        i += 4u;
    }

    // Handle remaining bytes
    while (i < path_len) {
        uint c = read_name_char(path_start + i);
        if (c == 47u) { // '/'
            start = i + 1u;
        }
        i++;
    }
    return start;
}

void main() {
    uint gid = gl_GlobalInvocationID.x;

    if (gid >= config.num_names) return;

    // Get the filename for this thread
    uint name_offset = name_offsets[gid];
    uint name_len = name_lengths[gid];

    bool case_insensitive = (config.flags & FLAG_CASE_INSENSITIVE) != 0u;
    bool match_path = (config.flags & FLAG_MATCH_PATH) != 0u;
    bool match_period = (config.flags & FLAG_PERIOD) != 0u;

    // For -name, match against basename only
    // For -path, match against full path
    uint match_start = name_offset;
    uint match_len = name_len;

    if (!match_path) {
        uint basename_start = find_basename_start(name_offset, name_len);
        match_start = name_offset + basename_start;
        match_len = name_len - basename_start;
    }

    bool matched = glob_match(
        0u,
        config.pattern_len,
        match_start,
        match_len,
        case_insensitive,
        match_period
    );

    results[gid].name_idx = gid;
    results[gid].matched = matched ? 1u : 0u;

    if (matched) {
        atomicAdd(match_count, 1u);
    }
}
